
#4.0 Input Values


#4.1 Form Submission

  const loginForm = document.getElementById('login-form');

  const loginInput = loginForm.querySelector('input');
  const loginButton = loginForm.querySelector('button');

  function onLoginBtnClick() {
    const username = loginInput.value;
    if (username === '') {
      alert('Please write your name');
    } else if (username.length > 15) {
      alert('Your name is too long');
    }
  }

  loginButton.addEventListener('click', onLoginBtnClick);

항상 user가 입력하는 값의 유효성을 확인하는 건 좋은 연습이지만,
user를 믿으면 안 됨


  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />

      <link rel="stylesheet" href="style.css" />

      <title>Momemtum App</title>
    </head>

    <body>
      <div id="login-form">
        <input
          required
          maxlength="15"
          type="text" placeholder="What is your name?" />
        <button>Log In</button>
      </div>

      <script src="app.js"></script>
    </body>
  </html>

`required` : input을 필수 입력 항목으로 만들어 줌
`maxlength` : input 자체적으로 초대 글자 수를 조절할 수 있음


*문제 : Log In을 클릭할 때,
<html>에서 확인 작업을 안 하고 있음
  그 이유는 <input>이 <form>이 아니기 때문

<input>의 유효성 검사를 작동시키기 위해서는
  <input>이 <form> 안에 있어야 됨


    <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />

      <link rel="stylesheet" href="style.css" />

      <title>Momemtum App</title>
    </head>

    <body>
      <form id="login-form">
        <input
          required
          maxlength="15"
          type="text"
          placeholder="What is your name?"
        />
        <button>Log In</button>
      </form>

      <script src="app.js"></script>
    </body>
  </html>


  // js
  const loginForm = document.getElementById('login-form');

  const loginInput = loginForm.querySelector('input');
  const loginButton = loginForm.querySelector('button');

  function onLoginBtnClick() {
    const username = loginInput.value;
    // username을 아직 받는다는 걸 확인하기 위해서
    console.log(username);
  }

  loginButton.addEventListener('click', onLoginBtnClick);


*문제
입력을 하고, 버튼을 누르면 새로고침이 실행되고 값이 사라짐
그리고 URL에 이상한 게 따라붙음
  file:///D:/Github/test/Nomadcoders/momentum/index.html?

⇒ 웹사이트를 재시작시키고 있음
  : <form>안에서 버튼을 누르거나, 엔터를 눌렀을 때
    <input>이 더 존재하지 않으면 자동으로 submit 되는 규칙이 있기 때문
    그래서 더 이상 click에 신경 쓸 필요가 없다 …


#4.2 Events

submit이라는 event가 발생하는 걸 아예 막거나 중간에 개입해서
submit event가 발생했다는 걸 파악하고 싶음

  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');

  function onLoginSubmit() {
    const username = loginInput.value;
    console.log(username);
  }

  loginForm.addEventListener('submit', onLoginSubmit);
  // submit event는 감지하지만, 여전히 새로고침은 못막음


`console.log(event);`
: `onLoginSubmit`함수의 첫 번째 argument로 발생한 일에 대해 필요로 할만한 정보를 줌
  ⇒ `onLoginSubmit (event)`  // event object를 담은 정보

// 콘솔창에서
submitEvents {...}

+) `EventListener`에 어떤 function을 추가하던 간에 javascript는
    모든 `EventListener` function의 첫번째 argument는
    항상 방금 실행된 event에 대한 여러 정보를 표시해줌 (optional)
  

  // 브라우저가 우리한테 어떤 정보를 넘겨주는지 확인
  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');
  // onLoginSubmit function이 하나의 argument를 받도록
  function onLoginSubmit(event) {
  // 브라우저의 기본 동작을 막아주는 function
    event.preventDefault();
    console.log(loginInput.value);
  }

  loginForm.addEventListener('submit', onLoginSubmit);

  /* <form>을 `submit`하는 순간에 브라우저가 새로고침하지 않고,
  user 정보를 저장 */

⇒ 아무것도 안하더라도, 아무것도 하지 않음으로써
javascritp가 어떤 정보를 담은 채로 function을 호출한다는 것을 알 수 있음


#4.3 Events part Two

  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');

  const link = document.querySelector('a');

  function onLoginSubmit(event) {
    event.preventDefault();
    console.log(loginInput.value);
  }

  function handleLinkClick() {
    alert('clicked');
  }

  loginForm.addEventListener('submit', onLoginSubmit);
  link.addEventListener('click', handleLinkClick);


`link.addEventListener('click', handleLinkClick());`와 다름
: `()`를 추가하면 이 함수는 한 번만 실행되고 그걸로 끝

⇒ 나는 javascript한테 함수의 이름만 주고, 실행하는 건 javascript의 몫


handleLinkClick ({information about the event just happened})
: 뭐가 클릭됐는지, 어디가 클릭됐는지 등 정보를 알고 싶을 때

javascript는 단순히 함수를 실행시키기만 하는 게 아니라,
함수를 실행시키는 동시에 그 함수에 첫번째 인자로 object를 넣어줌 (Review from last lesson)

⇒ 우리는 공간만 만들고 받기만 하면 됨


`console.log(event);`
: `handleLinkClick`함수의 첫 번째 argument로 발생한 일에 대해 필요로 할만한 정보를 줌
⇒ `handleLinkClick (event)`  // event object를 담은 정보

// 콘솔창에서
MouseEvents {screenX, screenY...}  // 니꼴라스
PointerEvent {...}  // 본인

+) MouseEvent보다 PointerEvent가 더 많은 기능을 포함하고 있어서 이제는 PointerEvent를 쓴다고 함
  (전자기기가 다양해져서 나왔다고 함)

* 참고 링크
[https://javascript.info/pointer-events](https://javascript.info/pointer-events)



#4.2 ~ #4.3 = event를 활용하는 방법, preventDefault를 사용하는 이유
              addListener 안에 있는 함수는 직접 실행하지 않는다는 것만 기억


#4.4 Getting Username

user가 이름을 제출하면 <form>을 없애고 싶음
  1. <html>요소 자체를 없애기
  2. <css>를 이용해서 숨기기

  .hidden {
    display: none;
  }


  // js
  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');

  function onLoginSubmit(event) {
    event.preventDefault();
    const username = loginInput.value;
    loginForm.classList.add('hidden');
    console.log(username);
  }

  loginForm.addEventListener('submit', onLoginSubmit);


<form>은 숨기고 <h1>은 표시
but <h1>에 표시할 텍스트가 있을 때만 표시되도록

  <body>
      <form id="login-form">
        <input
          required
          maxlength="15"
          type="text"
          placeholder="What is your name?"
        />
        <button>Log In</button>
      </form>
      <h1 id="greeting" class="hidden"></h1>
      <script src="app.js"></script>
    </body>


  // js
  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');
  const greeting = document.querySelector('#greeting');

  // 대문자로 쓰는 관습이 있음
  const HIDDEN_CLASSNAME = 'hidden';

  function onLoginSubmit(event) {
    event.preventDefault();
    loginForm.classList.add(HIDDEN_CLASSNAME);
    const username = loginInput.value;
    greeting.innerText = `Hello ${username}`;
    greeting.classList.remove(HIDDEN_CLASSNAME);
  }

  loginForm.addEventListener('submit', onLoginSubmit);


  // 출력값
  Hello ____


`const HIDDEN_CLASSNAME = "hidden";`
+) 일반적으로 string만 포함된 변수는 대문자로 표기하고, string을 저장하고 싶을 때 사용
그리고 이런 `loginForm`이나 `loginInput`처럼 중요한 정보를 담은 게 아니라서 대문자로 작성함


*문제
유저한테 인사하기는 성공했지만, 우리는 유저를 전혀 기억할 수 없다는 거 …
현재는 새로고침할 때마다 새로 로그인해야 함

새로고침할 때, <form>을 또 보지 않고도 이름이 저장되어 있으면


#4.5 Saving Username

