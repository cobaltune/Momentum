
#4.0 Input Values


#4.1 Form Submission

  const loginForm = document.getElementById('login-form');

  const loginInput = loginForm.querySelector('input');
  const loginButton = loginForm.querySelector('button');

  function onLoginBtnClick() {
    const username = loginInput.value;
    if (username === '') {
      alert('Please write your name');
    } else if (username.length > 15) {
      alert('Your name is too long');
    }
  }

  loginButton.addEventListener('click', onLoginBtnClick);

항상 user가 입력하는 값의 유효성을 확인하는 건 좋은 연습이지만,
user를 믿으면 안 됨


  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />

      <link rel="stylesheet" href="style.css" />

      <title>Momemtum App</title>
    </head>

    <body>
      <div id="login-form">
        <input
          required
          maxlength="15"
          type="text" placeholder="What is your name?" />
        <button>Log In</button>
      </div>

      <script src="app.js"></script>
    </body>
  </html>

`required` : input을 필수 입력 항목으로 만들어 줌
`maxlength` : input 자체적으로 초대 글자 수를 조절할 수 있음


*문제 : Log In을 클릭할 때,
<html>에서 확인 작업을 안 하고 있음
  그 이유는 <input>이 <form>이 아니기 때문

<input>의 유효성 검사를 작동시키기 위해서는
  <input>이 <form> 안에 있어야 됨


    <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />

      <link rel="stylesheet" href="style.css" />

      <title>Momemtum App</title>
    </head>

    <body>
      <form id="login-form">
        <input
          required
          maxlength="15"
          type="text"
          placeholder="What is your name?"
        />
        <button>Log In</button>
      </form>

      <script src="app.js"></script>
    </body>
  </html>


  // js
  const loginForm = document.getElementById('login-form');

  const loginInput = loginForm.querySelector('input');
  const loginButton = loginForm.querySelector('button');

  function onLoginBtnClick() {
    const username = loginInput.value;
    // username을 아직 받는다는 걸 확인하기 위해서
    console.log(username);
  }

  loginButton.addEventListener('click', onLoginBtnClick);


*문제
입력을 하고, 버튼을 누르면 새로고침이 실행되고 값이 사라짐
그리고 URL에 이상한 게 따라붙음
  file:///D:/Github/test/Nomadcoders/momentum/index.html?

⇒ 웹사이트를 재시작시키고 있음
  : <form>안에서 버튼을 누르거나, 엔터를 눌렀을 때
    <input>이 더 존재하지 않으면 자동으로 submit 되는 규칙이 있기 때문
    그래서 더 이상 click에 신경 쓸 필요가 없다 …


#4.2 Events

submit이라는 event가 발생하는 걸 아예 막거나 중간에 개입해서
submit event가 발생했다는 걸 파악하고 싶음

  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');

  function onLoginSubmit() {
    const username = loginInput.value;
    console.log(username);
  }

  loginForm.addEventListener('submit', onLoginSubmit);
  // submit event는 감지하지만, 여전히 새로고침은 못막음


`console.log(event);`
: `onLoginSubmit`함수의 첫 번째 argument로 발생한 일에 대해 필요로 할만한 정보를 줌
  ⇒ `onLoginSubmit (event)`  // event object를 담은 정보

// 콘솔창에서
submitEvents {...}

+) `EventListener`에 어떤 function을 추가하던 간에 javascript는
    모든 `EventListener` function의 첫번째 argument는
    항상 방금 실행된 event에 대한 여러 정보를 표시해줌 (optional)
  

  // 브라우저가 우리한테 어떤 정보를 넘겨주는지 확인
  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');
  // onLoginSubmit function이 하나의 argument를 받도록
  function onLoginSubmit(event) {
  // 브라우저의 기본 동작을 막아주는 function
    event.preventDefault();
    console.log(loginInput.value);
  }

  loginForm.addEventListener('submit', onLoginSubmit);

  /* <form>을 `submit`하는 순간에 브라우저가 새로고침하지 않고,
  user 정보를 저장 */

⇒ 아무것도 안하더라도, 아무것도 하지 않음으로써
javascritp가 어떤 정보를 담은 채로 function을 호출한다는 것을 알 수 있음


#4.3 Events part Two

  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');

  const link = document.querySelector('a');

  function onLoginSubmit(event) {
    event.preventDefault();
    console.log(loginInput.value);
  }

  function handleLinkClick() {
    alert('clicked');
  }

  loginForm.addEventListener('submit', onLoginSubmit);
  link.addEventListener('click', handleLinkClick);


`link.addEventListener('click', handleLinkClick());`와 다름
: `()`를 추가하면 이 함수는 한 번만 실행되고 그걸로 끝

⇒ 나는 javascript한테 함수의 이름만 주고, 실행하는 건 javascript의 몫


handleLinkClick ({information about the event just happened})
: 뭐가 클릭됐는지, 어디가 클릭됐는지 등 정보를 알고 싶을 때

javascript는 단순히 함수를 실행시키기만 하는 게 아니라,
함수를 실행시키는 동시에 그 함수에 첫번째 인자로 object를 넣어줌 (Review from last lesson)

⇒ 우리는 공간만 만들고 받기만 하면 됨


`console.log(event);`
: `handleLinkClick`함수의 첫 번째 argument로 발생한 일에 대해 필요로 할만한 정보를 줌
⇒ `handleLinkClick (event)`  // event object를 담은 정보

// 콘솔창에서
MouseEvents {screenX, screenY...}  // 니꼴라스
PointerEvent {...}  // 본인

+) MouseEvent보다 PointerEvent가 더 많은 기능을 포함하고 있어서 이제는 PointerEvent를 쓴다고 함
  (전자기기가 다양해져서 나왔다고 함)

* 참고 링크
[https://javascript.info/pointer-events](https://javascript.info/pointer-events)



#4.2 ~ #4.3 = event를 활용하는 방법, `preventDefault`를 사용하는 이유
              `addListener` 안에 있는 함수는 직접 실행하지 않는다는 것만 기억


#4.4 Getting Username

user가 이름을 제출하면 <form>을 없애고 싶음
  1. <html>요소 자체를 없애기
  2. <css>를 이용해서 숨기기

  .hidden {
    display: none;
  }


  // js
  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');

  function onLoginSubmit(event) {
    event.preventDefault();
    const username = loginInput.value;
    loginForm.classList.add('hidden');
    console.log(username);
  }

  loginForm.addEventListener('submit', onLoginSubmit);


<form>은 숨기고 <h1>은 표시
but <h1>에 표시할 텍스트가 있을 때만 표시되도록

  <body>
      <form id="login-form">
        <input
          required
          maxlength="15"
          type="text"
          placeholder="What is your name?"
        />
        <button>Log In</button>
      </form>
      <h1 id="greeting" class="hidden"></h1>
      <script src="app.js"></script>
    </body>


  // js
  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');
  const greeting = document.querySelector('#greeting');

  // 대문자로 쓰는 관습이 있음
  const HIDDEN_CLASSNAME = 'hidden';

  function onLoginSubmit(event) {
    event.preventDefault();
    loginForm.classList.add(HIDDEN_CLASSNAME);
    const username = loginInput.value;
    greeting.innerText = `Hello ${username}`;
    greeting.classList.remove(HIDDEN_CLASSNAME);
  }

  loginForm.addEventListener('submit', onLoginSubmit);


  // 출력값
  Hello ____


`const HIDDEN_CLASSNAME = "hidden";`
+) 일반적으로 string만 포함된 변수는 대문자로 표기하고, string을 저장하고 싶을 때 사용
그리고 이런 `loginForm`이나 `loginInput`처럼 중요한 정보를 담은 게 아니라서 대문자로 작성함


*문제
유저한테 인사하기는 성공했지만, 우리는 유저를 전혀 기억할 수 없다는 거 …
현재는 새로고침할 때마다 새로 로그인해야 함

새로고침할 때, <form>을 또 보지 않고도 이름이 저장되어 있으면


#4.5 Saving Username

뭔가를 저장하는 건 아주 자주 사용되는 기능 (유저의 이름이나 뭐가 되었든 간에)
ex ) 유튜브에서 우리가 볼륨을 조절하고 새로고침하면 유튜브가 그 볼륨값을 기억하듯이

user에게 매번 질문하기에는 번거로우니까 value(username)를 저장해 보자


우리의 경우 user가 누구인지 (이름을) 기억하고 싶음
classname을 추가하고 삭제하는 것처럼 그러니 아마 API가 존재하겠지 ?(아마도 비유인 듯)

우리가 브라우저에 뭔가를 기억할 수 있게 해주는 기능이 존재, 그 API의 이름이 local storage
local storage에 뭐가 들어있는지 보고 싶으면 개발자 도구를 이용하면 됨

  : ≫ - application - storage - local storage


`setItem`
: lacal storage API 중 하나인 method로, `setItem`을 활용하면 local storage에 정보를 저장

  local storage.setItem ("username", "nico");


`getItem`
: 값을 저장하고 난 다음에는 그 값을 볼러올 수 있음

  local storage.getItem ("username");

  // 출력값
  nico


`removeItem`
: (필요한 경우) 저장된 값을 지울 수 있음

  removeItem.removeItem ("username");


user가 이름을 제출할 때 그걸 저장

  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');
  const greeting = document.querySelector('#greeting');

  const HIDDEN_CLASSNAME = 'hidden';

  function onLoginSubmit(event) {
    event.preventDefault();
    loginForm.classList.add(HIDDEN_CLASSNAME);
    const username = loginInput.value;
    localStorage.setItem('username', username);
    greeting.innerText = `Hello ${username}`;
    greeting.classList.remove(HIDDEN_CLASSNAME);
  }

  loginForm.addEventListener('submit', onLoginSubmit);


>> local storage에 username이 존재하는지 확인하고 <form>을 표시하지 않고,
그런 경우 바로 <h1> 요소가 표시되도록

만약 local storage에 유저정보가 없다면 <form>이 먼저 표시되도록


#4.6 Loading Username

  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');
  const greeting = document.querySelector('#greeting');

  const HIDDEN_CLASSNAME = 'hidden';
  const USERNAME_KEY = 'username';

  function onLoginSubmit(event) {
    event.preventDefault();
    loginForm.classList.add(HIDDEN_CLASSNAME);
    const username = loginInput.value;
    localStorage.setItem(USERNAME_KEY, username);
    greeting.innerText = `Hello ${username}`;
    greeting.classList.remove(HIDDEN_CLASSNAME);
  }

  const savedUsername = localStorage.getItem(USERNAME_KEY);

  if (savedUsername === null) {
    // show the form
    loginForm.classList.remove(HIDDEN_CLASSNAME);
    loginForm.addEventListener('submit', onLoginSubmit);
  } else {
    // show the greetings
    greeting.innerText = `Hello ${savedUsername}`;
    greeting.classList.remove(HIDDEN_CLASSNAME);
  }


*문제
  greeting.innerText = `Hello ${savedUsername}`;
  greeting.classList.remove(HIDDEN_CLASSNAME);
  
  ⇒ 똑같은 동작을 두 번 반복하고 있음


어쩌면 이걸 함수로 만드는 게 나을지도
# normadcoders

: 바닐라 JS로 크롬 앱 만들기 (초보 자바스크립트 강의 ver.2)

**#1 [2021 UPDATE] INTRODUCTION**

### #1.1 What Are We Building

### ## 모멘텀 (App)-clone coding

새로운 탭 화면을 생산성 앱으로 대체할 거야

*모멘텀* 을 사용하기 위해선 (=중요한 기능들)

1. 로그인을 해야 함  // 사용자 이름을 물어봐서 누구인지 기억
2. 로그인하고 보면 여러 가지가 진행되고 있는 걸 확인할 수 있음
    1. 내 이름  // 날 기억하고 있다 +) 페이지를 아무리 새로고침 하더라도
        
        ㄴ javascript로 어떻게 사용자를 기억할 수 있는지 배울 예정
        
3. 시계도 있음
    
    ㄴ 우리만의 시계를 어떻게 만들지 배울 예정
    
4. 사용자가 현재 어느 지역에 있는지, 그 지역의 날씨는 어떤지도
    
    ㄴ 이걸 위해 geolocation 좌표 따는 법도 배울 예정
    
5. 배경 사진도 매일 바뀜
    
    ㄴ 무작위로 사진을 바꾸는 것도 배울 예정
    
6. 훌륭한 명언들
    
    ㄴ 무작위로 명언을 받아서 사용자에게 저장하는 법도 배울 예정
    
7. To-Do list 구현  // 이 강의의 main course
    
    ex ) Q. What is your main focus for today?  // 오늘 네 주요 작업이 뭐야?
    
     A. Record new course  // 새 강의 녹화
    
     To-Do list 출력 (option. 체크 박스)
    
     우측 하단에 더 많은 To-Do list 작성하는 메뉴도 구현
    

### #1.2 Requirements

그냥 기본만 알고

이것들이 어떻게 작용하고, 어떻게 서로를 보완하는지 정도만 알면 됨

** 굉장히 쉬운 수준의 요구사항 (but 확실한 이해도 필요)

```html
what is

폼을 어떻게 작성하는지
<body>, <head>, <input>, <button> ...
```

```css
what is

class(.) vs id(#) 차이점이 무엇인지
selector (선택자) ...
```

### ## kakaotalk-clone coding

### ****#1.3 Software Requirements****

컴퓨터에 대한 요구사항

- VS Code 다운받기
- 크로미움 기반의 웹브라우저를 사용하는 걸 강력 추천

### ****#1.4 Why JS****

1. 왜 JavaScript 가 이토록 인기폭발인지
2. 만약 자바스크립트를 배우기로 결정하고, 제대로 배워서, 전문가가 되면 얼마나 짱짱한 미래가 보장되어 있는지

⇒ 자바스크립트로 할 수 있는게 웹사이트 말고도 너무나도 많음

1. 자바스크립트가 이렇게 인기있고, 강력한게 어떤 사람들에겐 불행일 수도 있는 이유

… 투비컨티뉴

먼저

자바스크립트의 역사에대해

- 1995년 12월에 개발
- 이 프로그래밍 언어를 만드는데 10일밖에 안걸렸다고 ?

**자바스크립트가 프론트엔드로 쓸 수 있는 유일한 프로그래밍 언어

웹 전체를 아우르는 유일한 프로그래밍 언어

자바스크립트는 브라우저에 내정되어서 나와서 설치할 필요가 없음

### ****#1.5 Why JS II****

자바스크립트를 한계까지 사용하는 최고의 예시들

**three.js**

: 자바스크립트로 3d를 구현하게 해주는 라이브러리

데이터시각화도 구현가능

비디오게임도 가능

자바스크립트 기술을 좀 더 가다듬어서 더 깊게 배우고 싶다면

프레임워크로 넘어가면 됨

ㄴ 쉽게 말해 너가 하려는 일을 도와주는 도우미

그중에 하나가

**리액트 네이티브**

: 자바스크립트만으로 안드로이드랑 IOS 앱을 만들 수 있게 해줌

그 다음 단계는

**일렉트론**

: 자바스크립트, HTML, CSS로 데스크탑 앱을 만들 수 있게 해줌

⇒ 사람들이 다운로드하고 설치해서 쓰는 프로그램을 만들 수 있단 소리

wow

프론트엔드를 자바스크립트로 만든 다음에

백엔드까지 자바스크립트로 만들 수 있음

## wetube-clone coding

ㄴ 백엔드도 가진 웹사이트를 자바스크립트만으로 만드는 법 가르쳐줌

### ****#1.6 Online IDE****

ㄴ VS Code를 설치할 수 없는 사람들은 위한 영상

**#2 [2021 UPDATE] WELCOME TO JAVASCRIPT**

### ****#2.0 Your First JS Project****

이번 영상에서는 처음으로 자바스크립트 프로그래밍 언어를 다뤄볼거임

그런 후에 프로젝트를 만들고

HTML이랑 자바스크립트랑 어떻게 연결할 수 있는지 이해할거임

가장 먼저 자바스크립트를 다뤄보자

자바스크립트를 다루는 방법은 브라우저의 console을 사용하는 거

브라우저 창에 콘솔을 항상 띄워두는 습관들일 것

```html
!
// 자동으로 HTML구조 짜줌

<!-- 2. css 연결해주고 -->
<link rel="stylesheet" href="style.css">

  <title>Momemtum</title>  <!-- 1. 타이틀 먼저 바꾸고 -->

<!-- 3. js 연결해주면 세팅 끝 -->
<body>
  <script src="app.js"></script>
</body>
```

### ****#2.1 Basic Data Types****

프로그래밍에 있어서 가장 기본적인 두 가지 데이터타입

-number (숫자)

-text (문자)

ㄴ 가장 쉬운 기초적인 것들

- number (=interger =full number (정수)
    - ex) 2
- float
    - ex) 1.5

단지, 자바스크립트에는 `type`이라는 게 있고 그걸 알아서 이해한다는 점

자바스크립트에서 숫자를 사용할 수 있다는 것을 알았고

여러가지 타입의 숫자를 같이 쓸수도 있음

- hello (x)  vs  “hello” (o)
- text (=string)
    
    string : 처음부터 끝까지 모두 글자로 이뤄져 있다
    

### ****#2.2 Variables****

*아주 아주 간단한 계산기를 만들어 볼거임*

*그리고 왜 variables (변수)라는 개념이 필요한지 알아볼거임*

이번 영상에서는 variables (변수)의 가치에 대해서 이해해보도록

여러분은 게을러지는 법을 배워야 함

우리는 가능한 코드 작성량을 줄이고 싶단 말이지

코드를 적게 쓰는게 정말 좋은게

에러도 적고, 시간도 덜 걸리고, 전반적으로 더 좋음

variables 는 값을 저장하거나 유지하는 역할

- const (: constant (상수 : 바뀌지 않은 값 =계속 유지됨))

variable의 이름은 어떻게 정하느냐

- variable은 공백이 있을 수 없음
- 자바스크립트 세상에서는, 단어에 공백이 필요하다면
    - 일반적으로 다음 단어의 첫 문자를 대문자로 씀 : camelCase

### ****#2.3 const and let****

variable을 만드는 방법

- const
- let

이 둘의 차이점

const : constant (상수) : 값이 바뀔 수 없음

자 그럼 variable 값을 변경하는 게 필요한 경우도 있을까 ?

값을 바꾸는 게 필요할 때도 가끔있지. variable 값을 업데이트하고 싶을 수 있음

let은 새로운 것을 생성할 때 사용하는 것

글쓴이의 의도를 알 수 있음

많은 사람들이 const를 기본적으로 사용하고

만약 variable을 업데이트 하고 싶다면 let 을 씀

과거에는 var만 존재

매우 이상한 규칙이 있었는데

ver을 원한다면 어디서든 업데이트 할 수 있었음

문제점이 있는게 이러면 우리는 언어를 통한 보호를 받지 못함

만약에 실수로 var a의 값을 업데이트 해도 언어가 말해주지 않음

이게 const와 let을 만든 이유 : 이를 통해 몇몇 값을 보호할 수 있음

always const

sometims let

never var ㅋㅋㅋ

### ****#2.4 Booleans****

새로운 데이터타입 : boolean (true or false)

컴퓨터에서처럼 우리는 0과 1을 쓸 수 있는데

0 : 꺼져있다 / 1은 : 켜져있다

null ‘아무것도 없음’, 그 변수에 아무것도 없다

ㄴ 절대 자연적으로 발생하지 않음, null은 우리가variable 안에 어떤 것이 없다는 것을 확실히 하기 위해 쓰는 것 = 여기엔 값이 “없디”는 것을 알려줄 때 씀, “비어있어요”를 의도적으로 표현

undefined ‘존재하지 않는, 뭐가가 없는, 어떤 데이터타입도 아닌’

ㄴ 컴퓨터 메모리 안에는 존재해

공간은 있는데 값이 들어가지 않은거지

### ****#2.5 Arrays****

데이터를 정리하는 법

이게 컴퓨터과학에 있어서 매우 큰 부분인데, 바로 데이터 구조에 대한 것

기본적으로 우리가 데이터를 어떻게 하면 가능한 최선의 방법으로 정리할 수 있을까에 관한 것

사람들은 자료의 검색이나 삽일을 빠르게 할 수 있는 데이터의 저장방법에 대해 생각하는데 시간을 쏟음

우리는 데이터구조라든지 데이터를 어떻게 정리할지에 대해서 고민을 많이 함

우리가 지금 배울 수 있는 가장 기본적인 데이터 구조는 : array (배열)

데이터로 이뤄진 리스트

뭔가를 나열하는 방법

array 안에서 어떻게 찾을 수 있을까 배열이름[인덱스]

만약 우리가 앱을 만들 때, 사용자가 할 일 목록을 만들도록 할수 있지

그럼 그 할일 항목들을 어디에 저장할 수 있을까 = array 안에

array는 기본적으로 살아있는 것

array를 가지고 더 많은 것을 할 수 있는데

한가지는 이렇게 array 안에서 항목을 받아오는 것

또 가능한 건 원한다면 array에 하나 더 추가할 수도 있음

```jsx
const dayOfWeek = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"];

// get item from array
console.log (daysOfWeek[4]);

// add one more day to the array
daysOfWeek.push("sun");
```

아무든 array의 목적은 하나의 variable 안에 데이터의 list를 가지는 것

만약 네가 구매하고자 하는 것들의 리스트가 있는데, array 없이 어떻게 할래? ⇒ 계속해서 variable을 만들 수는 없다는 뜻

그렇다면 정말 많은 variable이 필요하게 될거고, 그러면 그 많은 걸 주문하지도 못하고, 다섯번째에 접근하지도 못하니까 list가 필요한거

array는 가장 기초적이고 필수적인 데이터 구조인데 값을 리스트로 정리하는 것

### ****#2.6 Objects****

나만의 xx.xx 같은 걸 만들 수 있음

가끔씩은 list 안에 정리하고 싶지 않을 수 있음

어떨때는 object 라는 것을 만들어야 할 때가 있음

이걸 설명할때 가장 좋은 예시는 비디오게임인거같음

게임을 만들고 있다고 상상

그래서 게임 안에서 캐릭터, 그러니까 플레이어를 만든다고 해보자

```jsx
const playerName = "nico";
const playerPoints = 121212;
const playerHansome = false;
const playerFat = "little bit";

player.name
player.points
player.hansome
/* 우리는 player.(-)이라는 특성들이
한 개체의 개체(entity),
즉 player에 대해서 설명하고 있다는 걸 알기 때문*/
```

우리가 하려는 것은 데이터를 가능한 최선으로 정리하는 것

```jsx
const player = {
	name: "nico",
	points: 10,
	fat: true,
};
```

ㄴ 우리는 object 안에서 =를 사용하지 않아 : 을 사용하지

그리고 한개의 property를 작성하고 난 뒤엔 콤마 (,)를 사용하는데,

property가 하나 더 올 수 있기 때문임

이것도 데이터를 정리하는데 아주 좋은 방식임

하지만 이건 리스트가 아니지. 리스트는 모든 값이 같은 의미를 갖음

배열과 달리 오브젝트에서는 그게 무엇인지 알 수 없는 property들도 있는 것

object를 업데이트 할 수도 있음

```jsx
const player = {
	name: "nico",
	points: 10,
	fat: true,
};

/* 우리는 이걸 array에는 넣을 수 없었는데
왜냐면 이게 뭘 뜻하는지 알 수 없기 때문에,
우리가 옆에 설명을 붙여야만 어떤 의미를 가지는지 알 수 있음 */

// 수정
console.log (player);
player.fat = false;
console.log (player);

// 추가
console.log (player);
player.lastName = "potato";
console.log (player);
```

object는 property를 가진 데이터를 저장하도록 해줌

### ****#2.7 Functions part One****

function은 너가 계속 반복해서 사용할 수 있는 코드 조각

코드의 반복을 최소한으로 줄이고 싶어서 function을 만드는거

function은 어떤 코드를 캡슐화해서, 실행을 여러번할수있게해줌

ex) 노래나, 동영상 재생 같은 계속 게속 반복해서 보고, 들을 수 있음

```jsx
function sayHello (){
	console.log ("Hello my name is ");
}

sayHello();
```

우리가 argument (인수)라는 것을 보내야 함

argument는 function을 실행하는 동안 어떤 정보를 function에게 보낼 수 있는 방법

function 실행버튼을 누르면서 뭔가를 보내는 법

### ****#2.8 Functions part Two****

우리가 데이터를 받는 방법은 여기 ()에 데이터를 추가하는 것

```jsx
// 1개의 argument
function sayHello (nameOfPerson){
	console.log (nameOfPerson);
}

sayHello("nico");
sayHello("dal");
sayHello("lynn");
```

```jsx
// 2개의 argument
function sayHello (nameOfPerson, age){
	console.log ("Hello my name is " + nameOfPerson +
" and I'm " + age);
}

sayHello("nico", 10);
sayHello("dal", 23);
sayHello("lynn", 21);
```

아주 간단한 계산기를 만들어보자

```jsx
function plus (firstNumber, secondNumber) {
	console.log (firstNumber + secondNumber);
}

plus (60, 8);
```

```jsx
function divide (a, b) {
	console.log (a / b);
}

divide (98,20);
```

```jsx
// player object
const player = {
	name: "nico",
	sayhello: function(otherPersonsName) {
		console.log ("Hello " + otherPersonsName + " nice ot meet you!");
	},
};

console.log (player.name);
player.sayHello ("lynn");
```

### ****#2.9 Recap****

*recapitulation : 요점의 되풀이, 요약, 개요*

데이터타입은 자바스크립트가 이해할 수 있는 데이터의 종류들

```jsx
// array item을 update
const toBuy = ["potato", "tomato", "pizza"];

console.log (toBuy[2]);
toBuy[2] = "water";
console.log (toBuy[2]);

// array 끝에 item을 하나 더 추가
toBuy.push ("meat");
console.log (toBuy);
```

### ****#2.10 Recap II****

list를 쓰면 항목들에 공통된 맥락이 있다

```jsx
const days = ["mon", "tue", "wed"]

// 이것들은 같은 종류, 즉 한 주의 요일들이란 것
```

의미가 있는 property를 저장하려고 할 때

(= 연관되어 있는 property들을 그룹으로 묶어서 저장해야 할 때)

```jsx
const player = {
	name: "Nico",
	age: 98,
};

console.log (player, console);
// console도 object 임

// object 중 한개의 element(item) 가져오기
console.log (player.name);

// object element update
player.name = "nicolas"
console.log (player);

// object를 만든 이후에, object 안에 새로운 item 만들기
player.sexy = "soon";
console.log (player);
```

** function 안에 미리 data를 넣어두는 것보다

function 밖에서 data를 넣을 수 있게 하는 것이 훨씬 나음

: function의 목적은 여러가지 일을 같은 코드로 하기 위함이기 때문

```jsx
function minusFive (potato) {
	console.log (potato - 5);
}

minusFive (5, 10, 12, 34, 4, 5, 6, 7);

// 출력값
0

/* 아주 많은 argument를 보내더라도 문제는 되지 않지만
위 function은 많은 argument를 받을 준비가 되어있지 않아서
오직 첫번째 argument만 받음 */
```

```jsx
const calculator = {
	add: function (a, b) {
		console.log (a, b);
	},
};

calculator.add(5, 1);
```

!! 코드 숙제 < +, -, /, ** 기능을 하는 object를 완성시키기>

// my answer

```jsx
const calculator = {
	add: function (a, b) {
		console.log (a + b);
	},
	minus: function (a, b) {
		console.log (a - b);
	},
	divided: function (a, b) {
		console.log (a / b);
	},
	multiplication: function (a, b) {
		console.log (a * b);
	},
	powerOf: function (a, b) {
		console.log (a ** b);
	},
	remainder: function (a, b) {
		console.log (a % b);
	}
};

// test code
calculator.add (1, 2);
calculator.minus (1, 2);
calculator.divided (1, 2);
calculator.multiplication (1, 2);
calculator.powerOf (1, 2);
calculator.remainder (1, 2);
```

### ****#2.11 Returns****

```jsx
const calculator = {
	add: function (a, b) {
		alert (a + b);
	}
}

// test code
console.log (calculator.add (1, 2));

// 출력값
undefined
```

```jsx
// 한국 나이를 계산하는 function
const age = 96;
	function calculateKrAge (ageOfForeigner) {
		ageOfForeigner + 2;
	}
```

함수가 그냥 어떤 기능을 수행하는 것이라고 생각하기보단

함수는 어떤 일을 수행하고 그 결과를 알려주는 것이라고 생각해봐

그냥 조용히 일을 수행할 뿐만 아니라, 너에게 결과를 줘

- 종종 조용히 일만 수행하는 function도 있을거고
- 종종 function으로부터 결과를 원할 때도 있을거야

console에서의 결과를 원하는 것이 아니라

alert 결고문에서의 결과를 원하는 것이 아니라

너의 코드에서 결과를 원할거야

```jsx
// 한국 나이를 계산하는 function
const age = 96;
	function calculateKrAge (ageOfForeigner) {
		ageOfForeigner + 2;
	}

const KrAge = calculateKrAge (Age);
console.log (KrAge);

// 출력값
undefined
```

KrAge는 아직 정의가 되지 않았어 (undefined)

뭔가를 하긴 했는데 

근데, 우리가 빠뜨린 건 return을 하는거야

```jsx
// 한국 나이를 계산하는 function
const age = 96;
	function calculateKrAge (ageOfForeigner) {
		return ageOfForeigner + 2;
	}

const KrAge = calculateKrAge (Age);
console.log (KrAge);

// 출력값
98
```

function 안에서 무언가를 return 하면

누군가가 function을 실행할 때, `calculateKrAge (Age)`을 대체할거야

그래서 이제는 console에 출력하려고 function을 쓰지 않을거임

대신 어떤 작업을 처리하고 그 결과를 return하기 위해 function을 사용할거임

⇒ function이 function의 밖과 소통하는 방법이라할 수 있음

가끔은 function을 쓸 때 그냥 조용히 작업시키고 결과는 필요없는 경우도 있을거임

```jsx
// 한국 나이를 계산하는 function
const age = 96;
	function calculateKrAge (ageOfForeigner) {
		ageOfForeigner + 2;
		return "hello";
	}

const KrAge = calculateKrAge (Age);
console.log (KrAge);

// 출력값
hello
```

우리는 function에서 console.log 하는 게 아니고

function의 반환 값과 같은 variable을 console.log 하고 있음

그래서

```jsx
const calculator = {
	add: function (a, b) {
		return a + b;
	},
	minus: function (a, b) {
		return a - b;
	},
	divided: function (a, b) {
		return a / b;
	},
	multiplication: function (a, b) {
		return a * b;
	},
	powerOf: function (a, b) {
		return a ** b;
	},
	remainder: function (a, b) {
		return a % b;
	}
};

// test code
const plusResult = calculator.add (2, 3);

// 출력값
5
```

calculator가 나에게 `calculator.add (2, 3);` 이 작업의 결과를 줄거임

`plusResult` 에 결과를 가지고 있음

return 하는 것의 포인트는 console.log 하는 것이 아니라

너는 궁극적으로 이 결과값 `plusResult` 을 화면에 보여줘야 할 거거든

출력값을 보면 잘 작동했는데

calculator 내부에서 console.log를 사용하지 않았어

다른 예제

```jsx
const calculator = {
	plus: function (a, b) {
		return a + b;
	},
};

const plusResult = calculator.plus(2, 3);

console.log (plusResult);

// 출력값
5
```

이 function은 반환 값이 있다면 이 function이 실행했을 때,

무언가를 실행하고 끝났을 때 너에게 반환값을 줘

보다시피 function 내부에서 console.log 하는 것과 큰 차이가 있음

function의 외부에서 값을 얻은 뒤에

그 값으로 네가 원하는 모든 것을 할 수 있어

```jsx
const plusResult = calculator.plus (2, 3);
const minusResult = calculator.minus (plusResult, 10);
const timesResult = calculator.times (10, minusResult);
const dividedResult = calculator.divided (timesResuly, plusResult);
const powerResult = calculator.powerResult (dividedResult, minusResult);
```

전에는 이런것을 하지 않았어

plus의 결과값을 얻지 못했었지

오직 console에서만 plus의 결과를 알 수 있지

console에서 값을 가져올 수는 없었어

console은 그냥 보여주기 위한 것일뿐

우리의 코드에서는 결과 값을 알 수 없었어

보다시피 지금 위 코드는 서로 의존하고 있어

이건 흐름을 이해하는데 아주 좋은 방법임

머릿속으로 값들을 바꾸면서 생각해보셈 그럼 보일거임

이렇게 값의 대체를 할 수 있어

`const plusResult` 여기 variable 자체가 function의 반환값이기 때문이지

물론 이걸 실행해보면 아무 일도 일어나지 않아

아무것도 console.log 하지 않았기 때문에

그대신 `plusResult` 에 접근할 수 있음 (그 외 나머지들도)

variable은 value가 있음

전에는 전부를 console.log했지만 지금은 그럴 필요가 없음

왜냐하면 function이 무언가를 return 하기 때문에

### ****#2.12 Recap****

return 을 해야하는 이유

a+b, a-b 같은 실제적인 계산은 javascript 코드에서는 그 value를 바로 얻을 수가 없어

```jsx
const plusResult = calculator.plus (2, 3);

// console.log 했을 때
const plusResult = undefined;

// return 했을 때
const plusResult = 5;
```

return 하는 대신 console.log를 했을 때

콘솔창에 결과값은 잘 작동되지만 plusResult는 undefined임

왜냐하면 function을 variable에 할당하면 그 variable은 plus function의 결과 type을 가지게 될거임

우린 function 외부에서 그 value를 얻길 원하지

그래서 이 function은 계산 작업을 하기에 아주 좋음

우리는 value를 도출해내고 싶음 we need a+b의 return 값이 필요해

variable에 function을 할당하면

이 variable은 function의 return value를 가지게 됨

** 한번 return 하면 function은 끝남

return을 하면 function은 작동을 멈추고 결과 값을 return 하고 끝나버림

이게 javascript의 규칙

```jsx
const calculator = {
	plus: function (a, b) {
		console.log ("hello");
		return a + b;
		console.log ("bye bye");  // console되지 않음
},
```

function은 계속 남아있는게 아님 (실행되고 나면) 사라지고, 마지막엔 결과를 남김

우리가 원하는 건, function 외부에서 value를 제공받는거

ex ) 사용자의 위치에 따라 날씨 정보를 알고 싶다면

날씨 정보를 구한 다음 그 값을 (콘솔이 아니라) 화면에 멋지게 출력할거임

그래서 console.log 대신에 return 을 사용할거임

⇒ 대체하기 (replacing)라 할 수 있지

// 여기까지 javascript 이론

// 다음 섹션부터는 javascript로 HTML을 수정, 변경, HTML을 인터렉티브하게 만드는 방법을 배울거임

### ****#2.13 Conditionals****

conditional (조건문)은 true인지 false인지 알려주기 때문에 아주 중요

뭔가를 확인해야 할 때 거의 대부분 사용

ex ) 사용자가 로그인되어 있다면, 무언가를 보여준다든지

아니면 사용자가 무언가를 할 때 반응하는 것을 만들때

먼저 `if` `else` 배우기 전에, 전에 했던 것 복습

- function을 호출하는 법
- argument (인자)
- string, boolean , number 같은 data type (자료형)

이것들을 연습해보고,

마지막에 if, else같은 조건문을 추가해볼게

아주 나이스한 계산기 만들기

이 계산기는 음주가 가능한 나이인지 아닌지를 알려줌

```jsx
// 유저의 나이를 묻는 것으로 시작
const age = prompt ("How old are you?");

console.log (age);

// 출력값 = string 이 기본값
// cancel
null

// ok
(비어있는 스트링)

// 156
156
```

새로고침을 하면 페이지가 계속 로딩하는 것처럼 보임

그리고 나이가 얼마인지를 물어봄, console에서는 아무 반응이 없음

이 페이지 (=prompt 창)는 javascript를 일시정지시키고 있음

ㄴ 그게 prompt 라는 function의 역할

내가 아무것도 안 하면 아무 일도 일어나지 않음

⇒ 보는 것처럼 이것은 javascript 코드의 실행을 멈추게 함

그게 더이상 prompt function을 사용하지 않는 이유임

prompt를 안 쓰는 이유는

message가 별로 안 예쁘고,

아무런 스타일 즉 css 를 적용시킬 수 없음 (= 버튼도 못 바꿈)

그리고 어떤 브라우저는 이런 팝업을 제한하기도 하고 

이건 아주 아주 오래된 방법임

⇒ 이건 브라우저로 할 수 있는 가장 직접적인 방법

요즘에는 대부분이 html, css로 만든 자신만의 창을 사용함 

아주 멋있고 사용자가 값을 작성할 수 있음

value의 type을 보려면 typeof 라는 키워드를 써야 돼

typeof를 하고, 한 칸 띄우고, variable을 적으면

우리는 한 type으로 받아서 다른 type으로 바꾸는 작업을 해볼거

(=type을 변경하는 방법)

“15" => 15
이것을 하기 위해 다른 function을 쓸거임

`perseint` (s: string, radix?: number): number

A string to convert into a number. Coverts a string to an integer

⇒ string을 number로 변환합니다 (text 말고 숫자만 가능)

```jsx
const age = prompt ("How old are you?");

console.log (typeof "15", typeof parseint("15"));

// 출력값
string  number

console.log (age, parseint(age));

// type
string  number
```

type을 아는 게 멋진 이유는

이 숫자가 어떤 수보다 큰지 작은지 알 수 있기 때문

string이면 숫자와 크기 비교를 할 수가 없음

number로 바꿔야 알 수 있음

또한 사용자에게 나이를 물어봤는데

사용자가 숫자가 아닌 걸 입력했을 경우를 인지할 수 있음

```jsx
// alert 창에 문자를 입력할 시
입력한 문자 NaN
```

우린 NaN인지 확인만 하면 됨

parseint 한 후의 age가 number형이 아니라면 message를 띄울 거

```jsx
const age = parseint (prompt ("How old are you?"));
```

// type를 변환하는 방법

다음 강의에서 배울 것은 무언가를 확인하는 방법

age가 number가 아니면 사용자에게 너의 age를 다시 입력하라고 할거임

만약 age가 NaN이 아니라면, (number라면)

내가 만든 계산의 결과를 보여줄거야 여기서 가장 중요한 키워드는 `if` 

만약 age가 NaN이라면 필요한 작업을 할 거고

그 반대라면 또 다른 작업을 할 거야

### ****#2.14 Conditionals part Two****

무언가가 NaN인지 판별하는 방법 : `isNaN ()` 

isNaN (number: number): boolean

A numeric value

Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number)

이 function을 사용하면 이 function 은 boolean으로 알려줄거임

isNaN을 사용하면 하나의 argument (인자)를 주면 number인지 아닌지를 알려줄거임

여기서 age는 사용자가 무엇을 입력하느냐에 따라 number가 아닐 수도 있음

```jsx
console.log (isNaN(age));

// 출력값
// 15 입력
false
// number 아닌 것(NaN)이 아니라는 뜻 (숫자라는 뜻)

// lalala 입력
true
// age가 NaN이라는 뜻
```

```jsx
// 한 가지 조건
if (condition: 조건) {
	// condition === true : 조건이 참일 때 실행할 코드
}
```

```jsx
// 두가지 조건
if (condition) {
	// condition === true
} else {
	// condition === flase : 조건이 거짓일 때 실행할 코드
}
```

condition (조건) 자리에는 무엇이 들어가야 할까

condition은 boolean으로 판별 가능해야 됨 (= true or false여야 함)

```jsx
const age = parseint (prompt ("How old are you?"));
// parseint로 string을 number로 변환하려 함

// isNaN으로 Number인지 아닌지 확인하려 함
if (isNaN(age)) {
	console.log ("Please write a number");
} else {
	console.log ("Thank you for writing  your age");
}
```

+) 여기서 더 좋게 만들 수 있는게 계산을 할 수 있음

age가 number라면, 나중에는 18세 이하인지를 판별하고

그러면 술을 마실 수 없다고 알려줘야 함

그리고 18세 초과이고 50세 이하라면 음주할 수 있다고 알려줘야 함

50세 초과라면 음주를 그만하는 게 좋지 않을까요? 라고 말할 수 있음 ㅋㅋㅋ 건강이 걱정돼요 하면서 ⇒ 다음 강의에서

### ****#2.15 Conditionals part Three****

조건이 많은 경우에 if는 하나 이상 필요할 수 있음

그래서 else를 하는 대신 else if로 연결

else if는 else와 비슷한데 거기에 if를 더한 개념

즉 이 if가 false일 때 한 가지 condition을 더 사용할 수 있게 해줌

```jsx
const age = parseint (prompt ("How old are you?"));

if (isNaN(age)) {
	// age가 NaN일 때 실행
	console.log ("Please write a number");
	// 근데 age가 number이면 다른 condition을 확인
} else if (age < 18){
	console.log ("You are too young");
} else {
	console.log ("You can drink");
}
```

두가지의 조건을 동시에 확인 (age가 18 이상이고 50 이하인지)

```jsx
const age = parseint (prompt ("How old are you?"));

if (isNaN(age)) {
	console.log ("Please write a number");
} else if (age < 18){
	console.log ("You are too young");
} else if (age >= 18 && age <= 50){
	// && AND는 왼쪽, 오른쪽 조건이 둘 다 true여야 하는 거라고 알림
	// || OR은 둘 중 하나만 true인지 확인
	console.log ("You can drink");

} else {
	console.log ("You can't  drink");
}
```

```jsx
const age = parseint (prompt ("How old are you?"));

if (isNaN(age) || age < 0) {
	console.log ("Please write a real positive number");
} else if (age < 18){
	console.log ("You are too young");
} else if (age >= 18 && age <= 50){
	console.log ("You can drink");
} else if (age > 50 && age <= 80){
	console.log ("You should exercise");
} else if (age > 80) {
	console.log ("You can do whatever you want");
}

// else는 선택적 사항 = else를 꼭 사용해야 하는 건 아님
```

### ****#2.16 Recap****

값이 동일한지도 체크할 수 있음

뭔가가 어떤 값이랑 그야말로 같은지 확인하고 싶을 때도 있지

```jsx
const age = parseint (prompt ("How old are you?"));

if (isNaN(age) || age < 0) {
	console.log ("Please write a real positive number");
} else if (age < 18){
	console.log ("You are too young");
} else if (age >= 18 && age <= 50){
	console.log ("You can drink");
} else if (age > 50 && age <= 80){
	console.log ("You should exercise");
	/* 하단 조건 때문에 현 조건이 실행이 되지 않을까봐
		 위치 조정 = 적는 순서에 관해 잘 생각해야 함

		 순서에 따라 위 조건이 아래 조건을 중첩시킬 수 있음*/
} else if (age === 100) {
	console.log ("wow you are wise");
/* age가 100이 아니라면 ?
	} else if (age !== 100) {
	console.log ("wow you are wise"); */
} else if (age > 80) {
	console.log ("You can do whatever you want");
}
```

한 개의 (=)는 value를 할당하는 것

(===)는 A(왼)가 B(오)라면? 을 확인하는 것 

더 많은 condition을 추가할 수 있나요?

```jsx
// of course
} else if (age >= 18 && age <= 50 && true) {
```

```jsx
// of course 2
if ((a && b) || (c && d) || (x && w)) {
// (3) (2) (1) 순
```

** javascript는 작은 괄호부터 시작해서 큰 괄호순

이제 html과 상호작용하는 단계로 넘어갈 준비 완

그리고 사용자와 상호작용하는 부분이 가장 중요

javascript는 본래 사용자와 상호작용하기 위해 만들어졌음

키보드 입력, 마우스 클릭 등의 event를 listen (감지) 해야 함

그리고 javascript로 html을 수정하는 방법도 …

### ****#3.0 The Document Object****

콘솔창에서 `document`를 치면 <html>를 볼 수 있음

브라우저가 <html> 정보가 아주 많이 들어있는 `document` 라는 `object`를 전달해줌

콘솔창에서 `console.dir (document)`를 치면 그저 `object`

`document`는 정말 많은 것들이 들어있는 `object`

javascript에서

<html> `document` 객체로부터 `title`을 가지고 올 수 있음

```jsx
// <html> 코드를 javascript 관점에서 보는 거
// 콘솔창에서
document.title

// 출력값
"Momentum"
```

+) 생각해보면 object에서 properties를 가지고 올 수 있음, properties 값을 바꿀 수도 있음

만약에 `document.title` 항목을 변경한다면 ?

```jsx
// 콘솔창에서
document.title = "Hi"

// 출력값
"Hi"
```

⇒ 보다시피 javascript에서 <html>을 읽어올뿐만 아니라, 변경도 가능

물론 콘솔창에서 변경한 건 새로고침 하면 이전값으로 돌아감

### ****#3.1 HTML in Javascript****

javascript로 정보를 가지고 올 수 있는 방법

: document 객체와, element를 가져오는 수많은 함수들을 이용

`<h1 id=”title”>` 이 id로 어떻게 가지고 올 수 있을까

```jsx
// 콘솔창에서
document.getElementById ("title")
			   // 이 함수는 string을 전달받는 함수

// 출력값
<h1 id="title">Geab me!</h1>
```

element를 더 자세하게 보여주는 `console.dir ()`

```jsx
// 콘솔창에서
autofocus: false

// <html>에서
<h1 autofocus id="title">Geab me!</h1>

// 다시 콘솔창에서
autofocus: true
```

<html>을 가지고 오는거지만, 그걸 javascript에서 하고 있음

그리고 javascript는 이 <html> element를 가지고 오지만, <html>자체를 보여주지는 않음 대신 javascript에서 이 <html>을 표현하는 object를 보여줌

```jsx
// 콘솔창에서
className: ""

// <html>에서
<h1 autofocus class="hello" id="title">Geab me!</h1>

// 다시 콘솔창에서
className: "hello"
```

그러면 우리가 className 같은 항목들을 가지고 올 수 있다는 것을 의미

```jsx
// app.js에서
const title = document.getElementById('title');

title.innerText = "Got you!";

// 출력값
<h1 class="hello" id="title">Got you!</h1>

// app.js에서
console.log (title.id);
console.log (title.className);

// 출력값
title
hello
```

<html>에서 항목들을 가져오는 방법

1. document 에서 항목들을 가지고 오는 것
2. 이 document 항목들을 변경하는 것

### ****#3.2 Searching For Elements****

`getElementById` 가 아닌 hello class를 사용하는 방법

가끔은 많은 element를 한번에 가지고 와야하는 경우가 있을 때

: `getElementsByClassName ()`

```jsx
// <html>에서
<h1 class="hello">Grab me!</h1>
<h1 class="hello">Grab me!</h1>
<h1 class="hello">Grab me!</h1>
<h1 class="hello">Grab me!</h1>
<h1 class="hello">Grab me!</h1>

// app.js에서
const hellos = document.getElementsByClassName ("hello");

console.log (hellos);

// 출력값
HTMLCollection(5) [h1.hello, h1.hello, h1.hello, h1.hello,
h1.hello]  // 이건 array
```

이건 많은 <h1>이 들어있는 array라서 `hello”.”` 으로 뭔가를 가져올 수 없음

그런데 대부분의 경우에는 class name을 모든 곳에 추가하지는 않음

```jsx
// <html>에서
<div class = "hello">
	<h1>Grab me!</h1>
</div>

// app.js에서
const title = document.getElementsByTagName('h1');

console.log(title);

// 출력값
HTMLCollection [h1]
```

*`*tag`는 `anchor`, `div`, `section`, `button` 같은 것들을 의미*

니꼴라스 기준, element를 가지고 오는 가장 멋진 방법

: `querySelector` 와 `querySelectorAll`

*`*querySelector`는 element를 css방식으로 검색할 수 있음*

⇒ `hello`란 class 내부에 있는 <h1>을 가지고 올 수 있음

```jsx
// app.js에서
const title = document.querySelector(".hello h1");
		/* css selector를 사용해서 class hello를 찾고,
			 그 안에 있는 h1을 가져와 달라고 함 */

console.log(title);

// 출력값
<h1>Grab me!</h1>
```

**hello가 class name이라는 것과 그 안의 <h1>을 명시해줘야 함

`*querySelector*`는 찾으면 단 하나의 element를 return 해주고, 

못찾으면 `null`

그런데 이 element를 찾을 수 있다면, 다른 모든 element도 찾을 수 있어야 하겠지 but 첫번째것 하나만 나옴

```jsx
// <html>에서
<div class = "hello">
	<h1>Grab me 1!</h1>
</div>
<div class = "hello">
	<h1>Grab me 2!</h1>
</div>
<div class = "hello">  // 세개가 있다고 가정
	<h1>Grab me 3!</h1>
</div>

// app.js에서
const title = document.querySelector(".hello h1");
const title = document.querySelector(".hello h1:first-child");

console.log(title);

// 출력값
<h1>Grab me 1!</h1>
```

*(method)*

*ParentNode.querySelector<Element>ㅛ*

*(selectors: string): Element (+2 overloads)*

*Returns the **first element** that is a descendant of node that matches selectors*

만약 이 세개 모두 가져오고 싶다면

```jsx
// app.js에서
const title = document.querySelectorAll(".hello h1");
```

`querySelectorAll`은 세개의 <h1>이 들어있는 array를 가져다줌

⇒ selector 안의 조건에 부합하는 모든 element를 가져다줌

```jsx
const title = document.querySelector("#hello");
const title = document.getElementById ("hello")
```

위 두 코드는 작성하는 법은 달라도, 같은 일을 함

하지만 여기서 <h1>을 가지고 오고 싶다거나,

hello란 id 하위의 form을 가져온다든지 하는 것들은 getElementById 로는 할 수 없음

### ****#3.3 Events****

```jsx
const title = document.querySelector("div.hello:first-child h1");

console.dir (title);

title.style.color = "blue";
```

위와 같이 <h1>의 <style>을 javascript에서 변경할 수 있음

하지만 javascript에서 대부분 작업할 일은 event를 listen 하는 것

*event란

ex ) click, <h1> 위로 마우스 올리기, 입력을 끝내거나, 이름을 적거나, enter를 누르는 것, wifi에서 접속이 해제될 경우 …

웹사이트에서 click event를 감지하는 방법

```jsx
const title = document.querySelector("div.hello:first-child h1");

function handleTitleClick () {
	title.style.color = "blue";
}

// click event를 listen하고
title.addEventListener("click", handleTitleClick);
// click event가 발생하면 위 function이 동작하길 원함

/* 여기서 handleTitleClick '()' 이걸 안넣은걸 꼭 기억
	 우린 바로 실행을 시키고 싶은게 아니고,
	 event가 발생하면 동작하길 바래서 '()'는 생략 */
```

javascript에 무슨 event를 listen하고 싶은지 알려줘야 함

왜냐하면 모든 event에 대해서 알고 싶은 것이 아니고, 단 하나의 event만 알아보고 싶기 때문

### ****#3.4 Events part Two****

listen하고 싶은 event를 찾는 가장 좋은 방법

1. 구글에 찾고싶은 element의 이름, h1 element를 검색

ex ) h1 html element mdn

스크롤 하다 보면 링크에 Web APIs라는 문장이 포함된 페이지가 있음

왜냐하면 이건 javascript관점의 HTML Heading Element란 의미이기 때문

1. property 이름 앞에 on-이 붙어있다면 그게 바로 event listener
    
    * event를 사용할때에는 ex ) onaborr 대신 abort로 사용해야함
    

```jsx
// javascript 에서
console.dir (title);
						// 해당 element

// 콘솔창에서 확인
```

mouseenter

: 마우스가 title 위에 올라갈 때, click은 하지 않고 그냥 위에 위치할 때의 event

```jsx
const title = document.querySelector("div.hello:first-child h1");

function handleTitleClick () {
	title.style.color = "blue";
}

function handleMouseEnter () {
	title.innerText = "Mouse is here!";
}

function handleMouseLeave () {
	titile.innerText = "Mouse is gone!";
}

title.addEventListener("click", handleTitleClick);
title.addEventListener("mouseenter", handleMouseEnter);
title.addEventListener("mouseleave", handleMouseLeave);
```

### ****#3.5 More Events****

event를 사용하는 데에는 두가지 방법

1. `addEventListener()`를 통해서 event들을 listen할 수도 있고,

```jsx
title.addEventListener("click", handleTitleClick);
```

1.  oneventname property에 event listener를 할당함으로써 event를 listen할 수 있음

```jsx
title.onclick = handleTitleClick;
```

니꼴라스가 `addEventListener`를 더 선호하는 이유

: 나중에 `removeEventListener`를 통해서 event listener를 제거할 수 있기 때문

window와 관련된 event : resize

```jsx
function handleWindowResize () {
	document.body.style.backgrounColor = "tomato";
}

window.addEventListener ("resize", handleWindowResize);
// document와 같이 window도 제공
```

clipboard에 관련된 event : copy, paste

```jsx
function handleWindowCopy () {
	alert ("copier!");
}

window.addEventListener ("copy", handleWindowCopy);
```

wifi (connection)에 관련된 event : offline, online

```jsx
function handleWindowOffline () {
	alert ("SOS no WIFI");
}

function handleWindowOnline () {
	alert ("ALL GOOD");
}

window.addEventListener ("offline", handleWindowOffline);
window.addEventListener ("online", handleWindowOnline);
```

### ****#3.6 CSS in Javascript****

내가 무언가가 true인지를 확인해야 한다는거

```jsx
const title = document.querySelector("div.hello:first-child h1");

function handleTitleClick () {
	console.log (h1.style.color);  // getter
	title.style.color = "blue";  // setter
		console.log (h1.style.color);  // getter
}

title.addEventListener("click", handleTitleClick);
```

유저가 title을 click했을 때 title을 파란색으로 칠해주고 싶어

그리고 한번 더 누르면 title의 색깔을 tomato로 변경하고 싶어

```jsx
const title = document.querySelector("div.hello:first-child h1");

function handleTitleClick () {
	if (h1.style.color === "blue") {
		h1.style.color = "tomato";
	} else {
		h1.style.color = "blue";
	}
}

title.addEventListener("click", handleTitleClick);
```

여기서 코드를 개선해서 더 깔끔하게 만드려면, `h1.style.color`를 이렇게 많이 호출하기 보다는

먼저, 이 color 현재 상태를 저장하는 것부터

```jsx
const title = document.querySelector("div.hello:first-child h1");

function handleTitleClick () {
	const currentColor = h1.style.color;
	let newColor;

	if (h1.style.color === "blue") {
		newColor = "tomato";
	} else {
		newColor = "blue";
	}
	h1.style.color = newColor;
}

title.addEventListener("click", handleTitleClick);
```

**element의 style을 javascript에서 변경하는 건 별로 선호하지 않음

### ****#3.7 CSS in Javascript part Two****

```jsx
// css
body {
  background-color: beige;
}

h1 {
  color: cornflowerblue;
}

.active {
  color: tomato;
}

// app.js
const h1 = document.querySelector('div.hello:first-child h1');

function handleTitleClick() {}
h1.className = 'active';  // getter 이면서 setter
h1.addEventListener('click', handleTitleClick);
```

```jsx
// className 수정
body {
  background-color: beige;
}

h1 {
  color: cornflowerblue;
  transition: color 0.5s ease-in-out;
}

.clicked {
  color: tomato;
}

// className 수정 및 if, else문 추가
const h1 = document.querySelector('div.hello:first-child h1');

function handleTitleClick() {
  if (h1.className === 'clicked') {
    h1.className = '';
  } else {
    h1.className = 'clicked';
  }
}

h1.addEventListener('click', handleTitleClick);
```

```jsx
// error가 발생할 수 있는 부분 축소 (코드 개선)
const h1 = document.querySelector('div.hello:first-child h1');

function handleTitleClick() {
  const clickedClass = 'clicked';
  if (h1.className === clickedClass) {
    h1.className = '';
  } else {
    h1.className = clickedClass;
  }
}

h1.addEventListener('click', handleTitleClick);
```

*버그

<html>에서 <h1>은 class가 없는 상태로 시작했는데

```jsx
<body>
    <div class="hello">
      <h1>Click me!</h1>
    </div>
    <script src="app.js"></script>
  </body>
```

만약 여기에 class가 있는 상태로 시작하면 어떻게 될까 ?

```jsx
// html
<body>
    <div class="hello">
      <h1 class="sext-font">Click me!</h1>
    </div>
    <script src="app.js"></script>
  </body>

// css
body {
  background-color: beige;
}

h1 {
  color: cornflowerblue;
  transition: color 0.5s ease-in-out;
}

.clicked {
  color: tomato;
}

.sexy-font {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
    Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

// 출력값
1. serif
2. sans-serif  // click
3. sans-serif  // click
```

저장하고 실행하면 <h1>이 sexy-font란 class와 함께 시작

하지만 javascript를 보면 우리는 이 class name을 교체했음

*javascript는 과거 따위 신경 안쓰고 그냥 교체함

⇒ 그래서 최초의 class name이 없어짐

```jsx
const h1 = document.querySelector('div.hello:first-child h1');

function handleTitleClick() {
  const clickedClass = 'clicked sexy-font';
  if (h1.className === clickedClass) {
    h1.className = '';
  } else {
    h1.className = clickedClass;
  }
}

h1.addEventListener('click', handleTitleClick);

// 출력값
1. serif
2. sans-serif  // click
3. serif  // click
```

`const clickedClass = 'clicked sexy-font';` 추가 후에야 clicked와 sexy-font가 제대로 추가되고 제거되고 있음

**하지만 이건 별로 좋은 방법이 아님

왜냐하면 만약 이걸 조금만 변경한다면, class 하나를 추가한다던지 하면

javascript는 물론이고 css가지 업데이트 해줘야 돼서

**우리는 javascript로 모든 class name을 변경하지 않아야 함

→ 이건 다음 영상에서

### ****#3.8 CSS in Javascript part Three****

class name을 바꾸는 다른 방법 = classList를 사용

classList에는 두 가지 옵션이 있음

- className은 이전에 class들은 상관않고 모든걸 교체해줌
- classList : class들의 목록으로 작업할 수 있게끔 허용해줌

`contains`

: classList의 function중 하나로, 이 function은 우리가 명시한 class가

<html> element의 class에 포함되어 있는지 말해줌

```jsx
const h1 = document.querySelector('div.hello:first-child h1');

function handleTitleClick() {
  const clickedClass = 'clicked sexy-font';
	// classList가 clicked를 포함하고 있는지 확인
  if (h1.classList.contains(clickedClass)) {
    h1.classList.remove(clickedClass);
  } else {
    h1.classList.add(clickedClass);
  }
}

h1.addEventListener('click', handleTitleClick);

// Elements 창에서
<h1 class="sext-font">Click me!</h1>
<h1 class="sext-font clicked">Click me!</h1>  // click
<h1 class="sext-font">Click me!</h1>  // click
```

`remove` or `add`를 통하여 javascript가 특정한 class name만 변경하도록 함

`toggle`

: classList의 function중 하나로, class name이 존재하는지 확인하고,

만약 class name이 존재한다면 toggle은 class name을 제거한 다음

그리고 만약 class name이 존재하지 않는다면 class name을 추가해줌

```jsx
const h1 = document.querySelector('div.hello:first-child h1');

function handleTitleClick() {
  h1.classList.toggle("clicked");
	// 이 string을 반복하는 순간이 constant를 생성해야할 때
}

h1.addEventListener("click", handleTitleClick);

// toggle은 아래와 같은 코드를 구현함
if (h1.classList.contains(clickedClass)) {
    h1.classList.remove(clickedClass);
  } else {
    h1.classList.add(clickedClass);
  }
```

### ****#4.0 Input Values****

### ****#4.1 Form Submission****

```jsx
const loginForm = document.getElementById('login-form');

const loginInput = loginForm.querySelector('input');
const loginButton = loginForm.querySelector('button');

function onLoginBtnClick() {
  const username = loginInput.value;
  if (username === '') {
    alert('Please write your name');
  } else if (username.length > 15) {
    alert('Your name is too long');
  }
}

loginButton.addEventListener('click', onLoginBtnClick);
```

항상 user가 입력하는 값의 유효성을 확인하는 건 좋은 연습이지만, user를 믿으면 안됨

```jsx
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="style.css" />

    <title>Momemtum App</title>
  </head>

  <body>
    <div id="login-form">
      <input
				 required
				 maxlength="15"
				 type="text" placeholder="What is your name?" />
      <button>Log In</button>
    </div>

    <script src="app.js"></script>
  </body>
</html>
```

`required` : input을 필수입력 항목으로 만들어 줌

`maxlength` : input 자체적으로 초대 글자수를 조절할 수 있음

 *문제

Log In을 클릭할 때 <html>에서 확인 작업을 안하고 있음

그 이유는 <input>이 <form>이 아니기 때문

<input>의 유효성 검사를 작동시키기 위해서는 <input>이 <form> 안에 있어야 됨

```jsx
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="style.css" />

    <title>Momemtum App</title>
  </head>

  <body>
    <form id="login-form">
      <input
        required
        maxlength="15"
        type="text"
        placeholder="What is your name?"
      />
      <button>Log In</button>
    </form>

    <script src="app.js"></script>
  </body>
</html>

// js
const loginForm = document.getElementById('login-form');

const loginInput = loginForm.querySelector('input');
const loginButton = loginForm.querySelector('button');

function onLoginBtnClick() {
  const username = loginInput.value;
	// username을 아직 받는다는 걸 확인하기 위해서
  console.log(username);
}

loginButton.addEventListener('click', onLoginBtnClick);
```

*문제

입력을 하고, 버튼을 누르면 새로고침이 실행되고 값이 사라짐

그리고 URL에 이상한게 따라붙음

*file:///D:/Github/test/Nomadcoders/momentum/index.html?*

⇒ 웹사이트를 재시작시키고 있음

: <form>안에서 버튼을 누르거나, 엔터를 눌렀을 때, <input>이 더 존재하지 않으면 자동으로 submit 되는 규칙이 있기 때문

그래서 더이상 click에 신경 쓸 필요가 없다 …

### ****#4.2 Events****

submit이라는 event가 발생하는 걸 아예 막거나 중간에 개입해서

submit event가 발생했다는 걸 파악하고 싶음

```jsx
const loginForm = document.querySelector('#login-form');
const loginInput = document.querySelector('#login-form input');

function onLoginSubmit() {
  const username = loginInput.value;
  console.log(username);
}

loginForm.addEventListener('submit', onLoginSubmit);
// submit event는 감지하지만, 여전히 새로고침은 못막음
```

`console.log(event);`

: `onLoginSubmit` 함수의 첫번째 argument로 발생한 일에 대해 필요로 할만한 정보를 줌

⇒ `onLoginSubmit (event)`  // event object를 담은 정보

// 콘솔창에서
submitEvents {...}

+) `EventListener` 에 어떤 function을 추가하던 간에 javascript는 모든 `EventListener` function의 첫번째 argument는 항상 방금 실행된 event에 대한 여러 정보를 표시해줌  (optional)

```jsx
// 브라우저가 우리한테 어떤 정보를 넘겨주는지 확인
const loginForm = document.querySelector('#login-form');
const loginInput = document.querySelector('#login-form input');
// onLoginSubmit function이 하나의 argument를 받도록
function onLoginSubmit(event) {
// 브라우저의 기본 동작을 막아주는 function
	event.preventDefault();
  console.log(loginInput.value);
}

loginForm.addEventListener('submit', onLoginSubmit);

/* <form>을 submit하는 순간에 브라우저가 새로고침하지 않고,
user 정보를 저장 */
```

⇒ 아무것도 안하더라도, 아무것도 하지 않음으로써 javascritp가 어떤 정보를 담은 채로 function을 호출한다는 것을 알 수 있음

### ****#4.3 Events part Two****

```jsx
const loginForm = document.querySelector('#login-form');
const loginInput = document.querySelector('#login-form input');

const link = document.querySelector('a');

function onLoginSubmit(event) {
  event.preventDefault();
  console.log(loginInput.value);
}

function handleLinkClick() {
  alert('clicked');
}

loginForm.addEventListener('submit', onLoginSubmit);
link.addEventListener('click', handleLinkClick);
```

`link.addEventListener('click', handleLinkClick());`와 다름
: `()`를 추가하면 이 함수는 한번만 실행되고 그걸로 끝

⇒ 나는 javascript한테 함수의 이름만 주고, 실행하는건 javascript의 몫

handleLinkClick ({information about the event just happened})

: 뭐가 클릭됐는지, 어디가 클릭됐는지 등 정보를 알고 싶을 때

javascript는 단순히 함수를 실행시키기만 하는 게 아니라,

함수를 실행시키는 동시에 그 함수에 첫번째 인자(argument)로 object를 넣어줌 (Review from last lesson)

⇒ 우리는 공간만 만들고 받기만 하면 됨

`console.log(event);`

: `handleLinkClick`함수의 첫번째 argument로 발생한 일에 대해 필요로 할만한 정보를 줌

⇒ `handleLinkClick (event)`  // event object를 담은 정보

// 콘솔창에서
MouseEvents {screenX, screenY...}  // 니꼴라스

PointerEvent {...}  // 본인

+) MouseEvent보다 PointerEvent가 더 많은 기능을 포함하고 있어서 이제는 PointerEvent를 쓴다고 함 (전자기기가 다양해져서 나왔다고 함)

* 참고 링크

[https://javascript.info/pointer-events](https://javascript.info/pointer-events)

#4.2~4.3 = event를 활용하는 방법, `preventDefault`를 사용하는 이유

`addListener` 안에 있는 함수는 직접 실행하지 않는다는 것만 기억

### ****#4.4 Getting Username****

user가 이름을 제출하면 <form>을 없애고 싶음

1. <html>요소 자체를 없애기
2. <css>를 이용해서 숨기기

```jsx
.hidden {
  display: none;
}

// js
const loginForm = document.querySelector('#login-form');
const loginInput = document.querySelector('#login-form input');

function onLoginSubmit(event) {
  event.preventDefault();
  const username = loginInput.value;
  loginForm.classList.add('hidden');
  console.log(username);
}

loginForm.addEventListener('submit', onLoginSubmit);
```

<form>은 숨기고 <h1>은 표시 but <h1>에 표시할 텍스트가 있을 때만 표시되도록

```jsx
<body>
    <form id="login-form">
      <input
        required
        maxlength="15"
        type="text"
        placeholder="What is your name?"
      />
      <button>Log In</button>
    </form>
    <h1 id="greeting" class="hidden"></h1>
    <script src="app.js"></script>
  </body>

// js
const loginForm = document.querySelector('#login-form');
const loginInput = document.querySelector('#login-form input');
const greeting = document.querySelector('#greeting');

// 대문자로 쓰는 관습이 있음
const HIDDEN_CLASSNAME = 'hidden';

function onLoginSubmit(event) {
  event.preventDefault();
  loginForm.classList.add(HIDDEN_CLASSNAME);
  const username = loginInput.value;
	greeting.innerText = `Hello ${username}`;
  greeting.classList.remove(HIDDEN_CLASSNAME);
}

loginForm.addEventListener('submit', onLoginSubmit);

// 출력값
Hello ____
```

`const HIDDEN_CLASSNAME = "hidden";`

+) 일반적으로 string만 포함된 변수는 대문자로 표기하고, string을 저장하고 싶을 때 사용

그리고 이런 `loginForm`이나 `loginInput`처럼 중요한 정보를 담은게 아니라서 대문자로 작성함

*문제

유저한테 인사하기는 성공했지만, 우리는 유저를 전혀 기억할 수 없다는서 … 현재는 새로고침할 때마다 새로 로그인해줘야 함

새로고침할 때, <form>을 또 보지않고도 이름이 저장되어 있으면

### ****#4.5 Saving Username****

뭔가를 저장하는 건 아주 자주 사용되는 기능 (유저의 이름이나 뭐가 되었던간에)

ex ) 유투브에서 우리가 볼륨을 조절하고 새로고침하면 유투브가 그 볼륨값을 기억하듯이

user에게 매번 질문하기에는 번거로우니까 value(username)를 저장해보자

우리의 경우 user가 누구인지 (이름을) 기억하고 싶음

classname을 추가하고 삭제하는것처럼 그러니 아마 API가 존재하겠지 ?(아마도 비유인듯)

classname을 추가하고 삭제하는거처럼 그러니 아마 API가 존재하겠지

우리가 브라우저에 뭔가를 기억할 수 있게 해주는 기능이 존재, 그 API의이름이 local storage

local storage에 뭐가 들어있는지 보고싶으면 개발자도구를 이용하면 됨

: ≫ - application - storage - local storage

`setItem`

: lacal storage API 중 하나인 method로, `setItem`을 활용하면 local storage에 정보를 저장할 수 있음

```jsx
local storage.setItem ("username", "nico");
```

`getItem`

: 값을 저장하고 난 다음에는 그 값을 볼러올 수 있음

```jsx
local storage.getItem ("username");

// 출력값
nico
```

`removeItem`

: (필요한 경우) 저장된 값을 지울 수 있음

```jsx
removeItem.removeItem ("username");
```

user가 이름을 제출할 때 그걸 저장

```jsx
const loginForm = document.querySelector('#login-form');
const loginInput = document.querySelector('#login-form input');
const greeting = document.querySelector('#greeting');

const HIDDEN_CLASSNAME = 'hidden';

function onLoginSubmit(event) {
  event.preventDefault();
  loginForm.classList.add(HIDDEN_CLASSNAME);
  const username = loginInput.value;
  localStorage.setItem('username', username);
  greeting.innerText = `Hello ${username}`;
  greeting.classList.remove(HIDDEN_CLASSNAME);
}

loginForm.addEventListener('submit', onLoginSubmit);
```

local storage에 username이 존재하는지 확인하고 <form>을 표시하지 않고, 그런 경우 바로 <h1> 요소가 표시되도록

만약 local storage에 유저정보가 없다면 <form>이 먼저 표시되도록

### ****#4.6 Loading Username****

```jsx
const loginForm = document.querySelector('#login-form');
const loginInput = document.querySelector('#login-form input');
const greeting = document.querySelector('#greeting');

const HIDDEN_CLASSNAME = 'hidden';
const USERNAME_KEY = 'username';

function onLoginSubmit(event) {
  event.preventDefault();
  loginForm.classList.add(HIDDEN_CLASSNAME);
  const username = loginInput.value;
  localStorage.setItem(USERNAME_KEY, username);
  greeting.innerText = `Hello ${username}`;
  greeting.classList.remove(HIDDEN_CLASSNAME);
}

const savedUsername = localStorage.getItem(USERNAME_KEY);

if (savedUsername === null) {
  // show the form
  loginForm.classList.remove(HIDDEN_CLASSNAME);
  loginForm.addEventListener('submit', onLoginSubmit);
} else {
  // show the greetings
  greeting.innerText = `Hello ${savedUsername}`;
  greeting.classList.remove(HIDDEN_CLASSNAME);
}
```

*문제

```jsx
  greeting.innerText = `Hello ${savedUsername}`;
  greeting.classList.remove(HIDDEN_CLASSNAME);
```

⇒ 똑같은 동작을 두번 반복하고 있음


어쩌면 이걸 함수로 만드는 게 나을지도

  const loginForm = document.querySelector('#login-form');
  const loginInput = document.querySelector('#login-form input');
  const greeting = document.querySelector('#greeting');

  const HIDDEN_CLASSNAME = 'hidden';
  const USERNAME_KEY = 'username';

  function onLoginSubmit(event) {
    event.preventDefault();
    loginForm.classList.add(HIDDEN_CLASSNAME);
    const username = loginInput.value;
    localStorage.setItem(USERNAME_KEY, username);
    paintGreeting(username);
  }

  function paintGreeting(username) {
    greeting.innerText = `Hello ${username}`;
    greeting.classList.remove(HIDDEN_CLASSNAME);
  }

  const savedUsername = localStorage.getItem(USERNAME_KEY);

  if (savedUsername === null) {
    // show the form
    loginForm.classList.remove(HIDDEN_CLASSNAME);
    loginForm.addEventListener('submit', onLoginSubmit);
  } else {
    // show the greetings
    paintGreeting(savedUsername);
  }


  /* 코드 해석
  (username)을 인자로 받는 함수를 만들었고

  `greeting`에 텍스트 `Hello ${username}`을 추가한 후,
  hidden class명을 지워주는 일

  하지만 우리가 함수를 호출하는 위치에 따라 유저정보는 다른 곳에서 옴

  ex 1) local storage에 유저정보가 있으면
  거기서 유저정보를 받아서 인자로 넣어주고

  ex 2) local storage에 유저정보가 없으면
  우리는 <form>의 submit을 기다리고,
  <form>이 submit되면 우리는 <input>으로부터 유저정보를 받고
  <input>에서 받은 user를 가진 `paintingGreetings`를 호출 */

